# ===================|===================
dark.py
# themes/dark.py
# -*- coding: utf-8 -*-

NAME = "æ·±è‰²æ¨¡å¼"

STYLESHEET = """
    /* å…¨å±€èƒŒæ™¯å’Œæ–‡å­— */
    QWidget { background-color: #1e1e2e; color: #cdd6f4; font-family: "Segoe UI", "Microsoft YaHei"; font-size: 13px; }
    
    /* å¼¹çª— */
    QDialog, QMessageBox, QColorDialog { background-color: #1e1e2e; }
    QMessageBox QLabel { color: #cdd6f4; }
    
    /* æŒ‰é’® */
    QPushButton { background-color: #313244; border: 1px solid #45475a; border-radius: 4px; padding: 5px; color: #cdd6f4; }
    QPushButton:hover { background-color: #45475a; border-color: #89b4fa; }
    QPushButton:pressed { background-color: #89b4fa; color: #1e1e2e; }
    
    /* è¾“å…¥æ¡† */
    QLineEdit, QTextEdit, QPlainTextEdit, QSpinBox, QDateEdit {
        background-color: #11111b; border: 1px solid #313244; border-radius: 4px; padding: 4px; color: #cdd6f4; selection-background-color: #89b4fa; selection-color: #1e1e2e;
    }
    QLineEdit:focus, QTextEdit:focus { border: 1px solid #89b4fa; }
    
    /* è¡¨æ ¼ */
    QListWidget, QTableWidget {
        background-color: #11111b; border: 1px solid #313244; alternate-background-color: #181825; outline: none;
    }
    QHeaderView::section { background-color: #181825; color: #a6adc8; border: none; padding: 6px; font-weight: bold; border-right: 1px solid #313244; }
    
    /* é€‰ä¸­æ ·å¼ */
    QTableWidget::item:selected, QListWidget::item:selected { 
        background-color: #313244; color: #89b4fa; border: none;
    }
    
    /* === æ»šåŠ¨æ¡æ ¸å¿ƒä¿®å¤ (å»é™¤ç½‘æ ¼ç‚¹) === */
    QScrollBar:vertical { background: #11111b; width: 12px; margin: 0px; }
    QScrollBar::handle:vertical { background: #45475a; min-height: 20px; border-radius: 4px; margin: 2px; }
    QScrollBar::handle:vertical:hover { background: #585b70; }
    QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical { height: 0px; }
    QScrollBar::add-page:vertical, QScrollBar::sub-page:vertical { background: none; } /* å…³é”®ï¼šå»é™¤éº»å­èƒŒæ™¯ */

    QScrollBar:horizontal { background: #11111b; height: 12px; margin: 0px; }
    QScrollBar::handle:horizontal { background: #45475a; min-width: 20px; border-radius: 4px; margin: 2px; }
    QScrollBar::add-line:horizontal, QScrollBar::sub-line:horizontal { width: 0px; }
    QScrollBar::add-page:horizontal, QScrollBar::sub-page:horizontal { background: none; } /* å…³é”®ï¼šå»é™¤éº»å­èƒŒæ™¯ */
    
    /* èœå• */
    QMenu { background-color: #1e1e2e; border: 1px solid #45475a; padding: 5px; }
    QMenu::item { padding: 5px 20px; border-radius: 4px; }
    QMenu::item:selected { background-color: #313244; color: #89b4fa; }
    
    /* ä¸‹æ‹‰æ¡† */
    QComboBox { background-color: #313244; border: 1px solid #45475a; border-radius: 4px; padding: 4px; }
    QComboBox QAbstractItemView { background-color: #1e1e2e; border: 1px solid #45475a; selection-background-color: #313244; color: #cdd6f4; }
    
    /* æç¤ºæ¡† */
    QToolTip { background-color: #11111b; color: #cdd6f4; border: 1px solid #45475a; padding: 4px; }
"""

# ===================|===================
database.py
ï»¿# -*- coding: utf-8 -*-
import sys
import os
import hashlib
import logging
from datetime import datetime, timedelta
from sqlalchemy import create_engine, Column, Integer, String, Text, Boolean, DateTime, ForeignKey, Table, Index, Float, func
from sqlalchemy.orm import declarative_base, relationship, sessionmaker, joinedload

log = logging.getLogger("Database")

Base = declarative_base()

item_tags = Table(
    'item_tags', Base.metadata,
    Column('item_id', Integer, ForeignKey('clipboard_items.id'), primary_key=True),
    Column('tag_id', Integer, ForeignKey('tags.id'), primary_key=True),
    Index('idx_tag_item', 'tag_id', 'item_id')
)

class ClipboardItem(Base):
    __tablename__ = 'clipboard_items'
    id = Column(Integer, primary_key=True, autoincrement=True)
    content = Column(Text, nullable=False)
    content_hash = Column(String(64), index=True, unique=True)
    note = Column(Text, default="")
    created_at = Column(DateTime, default=datetime.now)
    last_visited_at = Column(DateTime, default=datetime.now)
    visit_count = Column(Integer, default=0)
    sort_index = Column(Float, default=0.0)
    star_level = Column(Integer, default=0) 
    is_favorite = Column(Boolean, default=False)
    is_locked = Column(Boolean, default=False)
    is_pinned = Column(Boolean, default=False)
    group_color = Column(String(20), default=None)
    custom_color = Column(String(20), default=None)
    is_file = Column(Boolean, default=False)
    file_path = Column(Text, default=None)
    tags = relationship("Tag", secondary=item_tags, back_populates="items")

class Tag(Base):
    __tablename__ = 'tags'
    id = Column(Integer, primary_key=True, autoincrement=True)
    name = Column(String(50), unique=True, nullable=False)
    items = relationship("ClipboardItem", secondary=item_tags, back_populates="tags")

class DBManager:
    def __init__(self, db_path='sqlite:///clipboard_data.db'):
        log.info("åˆå§‹åŒ–æ•°æ®åº“...")
        if getattr(sys, 'frozen', False):
            base_dir = os.path.dirname(sys.executable)
        else:
            base_dir = os.path.dirname(os.path.abspath(sys.argv[0]))
        
        if db_path.startswith('sqlite:///'):
            db_name = db_path.replace('sqlite:///', '')
            full_path = os.path.join(base_dir, db_name)
            db_path = f'sqlite:///{full_path}'

        try:
            self.engine = create_engine(db_path + "?check_same_thread=False", echo=False)
            Base.metadata.create_all(self.engine)
            self.Session = sessionmaker(bind=self.engine)
            self._migrate_database()
        except Exception as e:
            log.critical(f"æ•°æ®åº“é”™è¯¯: {e}", exc_info=True)
            raise e
    
    def _migrate_database(self):
        import sqlite3
        db_file = str(self.engine.url).replace('sqlite:///', '')
        if not os.path.exists(db_file): return
        try:
            conn = sqlite3.connect(db_file)
            cursor = conn.cursor()
            cursor.execute("PRAGMA table_info(clipboard_items)")
            columns = [row[1] for row in cursor.fetchall()]
            check = {'group_color': 'VARCHAR(20)', 'custom_color': 'VARCHAR(20)', 'is_file': 'BOOLEAN DEFAULT 0', 'file_path': 'TEXT'}
            for col, dtype in check.items():
                if col not in columns:
                    cursor.execute(f"ALTER TABLE clipboard_items ADD COLUMN {col} {dtype}")
            conn.commit(); conn.close()
        except Exception as e:
            log.warning(f"è¿ç§»è­¦å‘Š: {e}")

    def get_session(self): return self.Session()

    def add_item(self, text, is_file=False, file_path=None):
        session = self.get_session()
        try:
            text_hash = hashlib.sha256(text.encode('utf-8')).hexdigest()
            existing = session.query(ClipboardItem).filter_by(content_hash=text_hash).first()
            if existing:
                existing.last_visited_at = datetime.now()
                existing.visit_count += 1
                session.commit()
                return existing, False
            
            min_sort = session.query(ClipboardItem).order_by(ClipboardItem.sort_index.asc()).first()
            new_sort = (min_sort.sort_index - 1.0) if min_sort else 0.0
            auto_note = os.path.basename(file_path) if (is_file and file_path) else (text.split('\n')[0].strip()[:100])
            
            new_item = ClipboardItem(content=text, content_hash=text_hash, sort_index=new_sort, note=auto_note, is_file=is_file, file_path=file_path)
            session.add(new_item); session.commit(); session.refresh(new_item)
            return new_item, True
        except: session.rollback(); return None, False
        finally: session.close()

    def get_all_items(self, filters=None, search_key="", sort_by="manual", selected_tags=None, advanced_filters=None):
        session = self.get_session()
        try:
            query = session.query(ClipboardItem).options(joinedload(ClipboardItem.tags))
            
            if filters:
                if filters.get('is_favorite'): query = query.filter(ClipboardItem.is_favorite == True)
                if filters.get('is_locked'): query = query.filter(ClipboardItem.is_locked == True)
                if filters.get('is_file'): query = query.filter(ClipboardItem.is_file == True)
                
                # === æ ¸å¿ƒä¿®æ”¹ï¼šçµæ´»çš„æ˜Ÿçº§ç­›é€‰ ===
                # å¦‚æœä¼ å…¥äº† star_levels åˆ—è¡¨ (ä¾‹å¦‚ [3, 5])ï¼Œåˆ™ç­›é€‰ star_level IN (3, 5)
                if filters.get('star_levels') and len(filters['star_levels']) > 0:
                    query = query.filter(ClipboardItem.star_level.in_(filters['star_levels']))

            if advanced_filters:
                if 'star_min' in advanced_filters: query = query.filter(ClipboardItem.star_level.between(advanced_filters['star_min'], advanced_filters['star_max']))
                if 'date_start' in advanced_filters:
                    s = datetime.combine(advanced_filters['date_start'], datetime.min.time())
                    e = datetime.combine(advanced_filters['date_end'], datetime.max.time())
                    query = query.filter(ClipboardItem.created_at.between(s, e))
            
            if selected_tags: query = query.join(item_tags).join(Tag).filter(Tag.name.in_(selected_tags))
            
            if search_key: query = query.filter(ClipboardItem.content.like(f"%{search_key}%") | ClipboardItem.note.like(f"%{search_key}%"))
            
            if sort_by == "manual": query = query.order_by(ClipboardItem.is_pinned.desc(), ClipboardItem.sort_index.asc())
            elif sort_by == "time_desc": query = query.order_by(ClipboardItem.is_pinned.desc(), ClipboardItem.created_at.desc())
            elif sort_by == "visit_desc": query = query.order_by(ClipboardItem.is_pinned.desc(), ClipboardItem.visit_count.desc())
            elif sort_by == "stars_desc": query = query.order_by(ClipboardItem.is_pinned.desc(), ClipboardItem.star_level.desc())
            elif sort_by == "size_desc": query = query.order_by(ClipboardItem.is_pinned.desc(), func.length(ClipboardItem.content).desc())
            
            return query.limit(200).all()
        except: return []
        finally: session.close()

    def get_tag_cloud(self):
        session = self.get_session()
        try: return session.query(Tag.name, func.count(item_tags.c.item_id).label('count')).join(item_tags).group_by(Tag.id).order_by(func.count(item_tags.c.item_id).desc()).all()
        except: return []
        finally: session.close()

    def update_sort_order(self, ids):
        session = self.get_session()
        try:
            for idx, i in enumerate(ids):
                if item := session.query(ClipboardItem).get(i): item.sort_index = float(idx)
            session.commit()
        except: pass
        finally: session.close()

    def update_field(self, item_id, field, value):
        session = self.get_session()
        try:
            if item := session.query(ClipboardItem).get(item_id): setattr(item, field, value); session.commit()
        except: pass
        finally: session.close()

    def remove_tag_from_item(self, item_id, tag_name):
        session = self.get_session()
        try:
            item = session.query(ClipboardItem).get(item_id)
            tag = session.query(Tag).filter_by(name=tag_name).first()
            if item and tag and tag in item.tags: item.tags.remove(tag); session.commit()
        finally: session.close()
            
    def add_tags_to_items(self, item_ids, tag_name):
        session = self.get_session()
        try:
            tag = session.query(Tag).filter_by(name=tag_name).first()
            if not tag: tag = Tag(name=tag_name); session.add(tag)
            items = session.query(ClipboardItem).filter(ClipboardItem.id.in_(item_ids)).all()
            for item in items: 
                if tag not in item.tags: item.tags.append(tag)
            session.commit()
        except: session.rollback()
        finally: session.close()
    
    def auto_delete_old_data(self, days=21):
        session = self.get_session()
        try:
            cutoff = datetime.now() - timedelta(days=days)
            old = session.query(ClipboardItem).filter(ClipboardItem.created_at < cutoff, ClipboardItem.is_locked == False).all()
            c = len(old)
            for i in old: session.delete(i)
            session.commit(); return c
        except: session.rollback(); return 0
        finally: session.close()

# ===================|===================
dialogs.py
ï»¿# -*- coding: utf-8 -*-
import logging
from PyQt5.QtWidgets import (QDialog, QVBoxLayout, QHBoxLayout, QPushButton, 
                             QLabel, QLineEdit, QListWidget, QListWidgetItem, 
                             QCheckBox, QSpinBox, QGridLayout, QDateEdit, 
                             QDialogButtonBox, QMessageBox, QScrollArea, QWidget,
                             QColorDialog)
from PyQt5.QtGui import QColor
from PyQt5.QtCore import Qt, QSize, QSettings, QDate

log = logging.getLogger("Dialogs")

class TagSelectorDialog(QDialog):
    def __init__(self, db_manager, current_item_id, parent=None):
        super().__init__(parent)
        self.db = db_manager
        self.current_item_id = current_item_id
        self.view_mode = "list"
        self.max_display = 50
        self.show_frequent = True; self.show_recent = True; self.show_recommended = True
        self.setWindowTitle("æ ‡ç­¾ç®¡ç†")
        self.setMinimumSize(450, 550)
        self.init_ui()
        self.load_tags()
    
    def init_ui(self):
        layout = QVBoxLayout(self); layout.setContentsMargins(15, 15, 15, 15)
        toolbar = QHBoxLayout()
        self.search_input = QLineEdit(); self.search_input.setPlaceholderText("ğŸ” æœç´¢...")
        self.search_input.textChanged.connect(self.filter_tags)
        self.search_input.returnPressed.connect(self.add_tag_from_search)
        toolbar.addWidget(self.search_input)
        
        btn_list = QPushButton("â˜°"); btn_list.setFixedWidth(30); btn_list.clicked.connect(lambda: self.switch_view("list"))
        btn_grid = QPushButton("âŠ"); btn_grid.setFixedWidth(30); btn_grid.clicked.connect(lambda: self.switch_view("grid"))
        btn_set = QPushButton("âš™"); btn_set.setFixedWidth(30); btn_set.clicked.connect(self.show_settings)
        toolbar.addWidget(btn_list); toolbar.addWidget(btn_grid); toolbar.addWidget(btn_set)
        layout.addLayout(toolbar)
        
        self.tag_list = QListWidget(); self.tag_list.itemDoubleClicked.connect(self.add_tag_from_list)
        layout.addWidget(self.tag_list)
        layout.addWidget(QLabel("ğŸ’¡ æç¤º: åŒå‡»æ ‡ç­¾æ·»åŠ  | å›è½¦é”®å¿«é€Ÿæ·»åŠ  | ESCå…³é—­"))
    
    def load_tags(self):
        self.tag_list.clear()
        tags = self.db.get_tag_cloud()
        for name, count in tags[:self.max_display]:
            item = QListWidgetItem(name if self.view_mode == "grid" else f"ğŸ·ï¸ {name}  ({count})")
            if self.view_mode == "grid": item.setTextAlignment(Qt.AlignCenter); item.setToolTip(f"{name} ({count})")
            item.setData(Qt.UserRole, name)
            self.tag_list.addItem(item)
        self.filter_tags(self.search_input.text())
    
    def filter_tags(self, text):
        for i in range(self.tag_list.count()):
            item = self.tag_list.item(i)
            item.setHidden(text.lower() not in item.data(Qt.UserRole).lower())
    
    def add_tag_from_search(self):
        tag = self.search_input.text().strip()
        if tag:
            self.db.add_tags_to_items([self.current_item_id], tag)
            self.search_input.clear(); self.load_tags()
            if self.parent(): self.parent().update_dock_panel(); self.parent().refresh_tag_cloud()
    
    def add_tag_from_list(self, item):
        self.db.add_tags_to_items([self.current_item_id], item.data(Qt.UserRole))
        if self.parent(): self.parent().update_dock_panel(); self.parent().refresh_tag_cloud()
    
    def switch_view(self, mode):
        self.view_mode = mode
        self.tag_list.setViewMode(QListWidget.IconMode if mode == "grid" else QListWidget.ListMode)
        self.tag_list.setResizeMode(QListWidget.Adjust if mode == "grid" else QListWidget.Fixed)
        self.tag_list.setGridSize(QSize(100, 40) if mode == "grid" else QSize())
        self.load_tags()

    def show_settings(self):
        d = QDialog(self); d.setWindowTitle("æ ‡ç­¾è®¾ç½®"); d.setMinimumSize(300, 250)
        layout = QVBoxLayout(d)
        layout.addWidget(QLabel("æ˜¾ç¤ºé€‰é¡¹"))
        c1 = QCheckBox("å¸¸ç”¨æ ‡ç­¾"); c1.setChecked(self.show_frequent)
        c2 = QCheckBox("æœ€è¿‘ä½¿ç”¨"); c2.setChecked(self.show_recent)
        c3 = QCheckBox("æ¨è"); c3.setChecked(self.show_recommended)
        layout.addWidget(c1); layout.addWidget(c2); layout.addWidget(c3)
        layout.addWidget(QLabel("æœ€å¤§æ•°é‡"))
        sp = QSpinBox(); sp.setRange(10, 200); sp.setValue(self.max_display)
        layout.addWidget(sp)
        btn = QPushButton("ç¡®å®š"); btn.clicked.connect(d.accept); layout.addWidget(btn)
        if d.exec_():
            self.show_frequent = c1.isChecked(); self.show_recent = c2.isChecked()
            self.show_recommended = c3.isChecked(); self.max_display = sp.value()
            self.load_tags()

class AdvancedFilterDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("é«˜çº§ç­›é€‰"); self.setMinimumWidth(350)
        layout = QVBoxLayout(self)
        
        sl = QHBoxLayout()
        sl.addWidget(QLabel("â­ æ˜Ÿçº§èŒƒå›´:"))
        self.s_min = QSpinBox(); self.s_min.setRange(0, 5)
        self.s_max = QSpinBox(); self.s_max.setRange(0, 5); self.s_max.setValue(5)
        sl.addWidget(self.s_min); sl.addWidget(QLabel("åˆ°")); sl.addWidget(self.s_max)
        layout.addLayout(sl)

        dl = QGridLayout()
        self.d_start = QDateEdit(); self.d_start.setDate(QDate.currentDate().addMonths(-1)); self.d_start.setCalendarPopup(True)
        self.d_end = QDateEdit(); self.d_end.setDate(QDate.currentDate()); self.d_end.setCalendarPopup(True)
        dl.addWidget(QLabel("ä»:"), 0, 0); dl.addWidget(self.d_start, 0, 1)
        dl.addWidget(QLabel("åˆ°:"), 1, 0); dl.addWidget(self.d_end, 1, 1)
        layout.addLayout(dl)

        bb = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        bb.accepted.connect(self.accept); bb.rejected.connect(self.reject)
        layout.addWidget(bb)

    def get_filters(self):
        return {"star_min": self.s_min.value(), "star_max": self.s_max.value(),
                "date_start": self.d_start.date().toPyDate(), "date_end": self.d_end.date().toPyDate()}

class ColorSelectorDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("é¢œè‰²é€‰æ‹©"); self.setMinimumSize(400, 500)
        self.selected_color = None
        self.init_ui(); self.load_history()
    
    def init_ui(self):
        layout = QVBoxLayout(self)
        layout.addWidget(QLabel("ğŸ¨ æ¨èé¢œè‰²"))
        gr = QGridLayout()
        cols = ["#ffadad", "#ffd6a5", "#fdffb6", "#caffbf", "#9bf6ff", "#a0c4ff", "#bdb2ff", "#ffc6ff",
                "#ef476f", "#ffd166", "#06d6a0", "#118ab2", "#073b4c", "#f72585", "#7209b7", "#3a0ca3"]
        for i, c in enumerate(cols): gr.addWidget(self.create_color_btn(c), i//8, i%8)
        layout.addLayout(gr)
        
        layout.addWidget(QLabel("ğŸ•’ æœ€è¿‘ä½¿ç”¨")); self.gh = QGridLayout(); layout.addLayout(self.gh)
        layout.addWidget(QLabel("âœï¸ è‡ªå®šä¹‰"))
        
        cl = QHBoxLayout()
        self.inp = QLineEdit(); self.inp.setPlaceholderText("#RRGGBB"); self.inp.textChanged.connect(self.upd_prev)
        cl.addWidget(self.inp)
        self.prev = QPushButton(); self.prev.setFixedSize(36, 36)
        cl.addWidget(self.prev)
        
        b_pick = QPushButton("è°ƒè‰²æ¿"); b_pick.clicked.connect(self.open_sys_dlg); cl.addWidget(b_pick)
        b_fav = QPushButton("â­"); b_fav.setFixedSize(36, 36); b_fav.clicked.connect(self.save_fav); cl.addWidget(b_fav)
        layout.addLayout(cl); layout.addStretch()
        
        bl = QHBoxLayout()
        b_clr = QPushButton("æ¸…é™¤é¢œè‰²"); b_clr.clicked.connect(self.clr_col); bl.addWidget(b_clr)
        bl.addStretch()
        b_can = QPushButton("å–æ¶ˆ"); b_can.clicked.connect(self.reject); bl.addWidget(b_can)
        b_ok = QPushButton("ç¡®å®š"); b_ok.clicked.connect(self.ok_act); bl.addWidget(b_ok)
        layout.addLayout(bl)
    
    def create_color_btn(self, c):
        b = QPushButton(); b.setFixedSize(32, 32); b.setStyleSheet(f"background-color: {c}; border-radius: 16px;")
        b.setCursor(Qt.PointingHandCursor); b.clicked.connect(lambda: self.sel_col(c))
        return b
    
    def load_history(self):
        h = QSettings("ClipboardApp", "ColorHistory").value("colors", [])
        if not h: h = ["#ffffff", "#000000", "#808080"]
        for i, c in enumerate(h[:16]): self.gh.addWidget(self.create_color_btn(c), i//8, i%8)
            
    def save_history(self, c):
        s = QSettings("ClipboardApp", "ColorHistory"); h = s.value("colors", [])
        if c in h: h.remove(c)
        h.insert(0, c); s.setValue("colors", h[:16])
        
    def save_fav(self):
        c = self.inp.text().strip()
        if QColor(c).isValid():
            s = QSettings("ClipboardApp", "ColorFavorites"); f = s.value("favorite_colors", [], type=list)
            if c not in f: f.insert(0, c); s.setValue("favorite_colors", f); QMessageBox.information(self, "æˆåŠŸ", f"å·²æ”¶è— {c}")
    
    def open_sys_dlg(self):
        c = QColorDialog.getColor(options=QColorDialog.DontUseNativeDialog)
        if c.isValid(): self.inp.setText(c.name()); self.selected_color = c.name()

    def sel_col(self, c): self.selected_color = c; self.save_history(c); self.accept()
    def upd_prev(self, t): 
        if QColor(t).isValid(): self.prev.setStyleSheet(f"background-color: {t}; border-radius: 4px;")
    def ok_act(self):
        t = self.inp.text()
        if QColor(t).isValid(): self.sel_col(t)
        elif self.selected_color: self.sel_col(self.selected_color)
        else: self.reject()
    def clr_col(self): self.selected_color = ""; self.accept()

# ===================|===================
light.py
# themes/light.py
# -*- coding: utf-8 -*-

NAME = "Ç³É«Ä£Ê½"

STYLESHEET = """
    QWidget { background-color: #f5f5f7; color: #333333; font-family: "Segoe UI", "Microsoft YaHei"; font-size: 13px; }
    QDialog, QMessageBox, QColorDialog { background-color: #ffffff; }
    QMessageBox QLabel { color: #333333; }
    
    QPushButton { background-color: #ffffff; border: 1px solid #d1d1d6; border-radius: 4px; padding: 5px; color: #333333; }
    QPushButton:hover { background-color: #e5e5ea; border-color: #007aff; }
    QPushButton:pressed { background-color: #007aff; color: #ffffff; }
    
    QLineEdit, QTextEdit, QPlainTextEdit, QSpinBox, QDateEdit {
        background-color: #ffffff; border: 1px solid #d1d1d6; border-radius: 4px; padding: 4px; color: #333333; selection-background-color: #007aff; selection-color: #ffffff;
    }
    QLineEdit:focus, QTextEdit:focus { border: 1px solid #007aff; }
    
    QListWidget, QTableWidget {
        background-color: #ffffff; border: 1px solid #d1d1d6; alternate-background-color: #f2f2f7; outline: none;
    }
    QHeaderView::section { background-color: #e5e5ea; color: #333333; border: none; padding: 6px; font-weight: bold; border-right: 1px solid #d1d1d6; }
    QTableWidget::item:selected, QListWidget::item:selected { background-color: #e5f1ff; color: #007aff; border: none; }
    
    QScrollBar:vertical { background: #f5f5f7; width: 12px; }
    QScrollBar::handle:vertical { background: #c7c7cc; min-height: 20px; border-radius: 6px; margin: 2px; }
    QScrollBar::handle:vertical:hover { background: #aeaeb2; }
    
    QMenu { background-color: #ffffff; border: 1px solid #d1d1d6; padding: 5px; }
    QMenu::item { padding: 5px 20px; border-radius: 4px; color: #333333; }
    QMenu::item:selected { background-color: #e5f1ff; color: #007aff; }
    
    QComboBox { background-color: #ffffff; border: 1px solid #d1d1d6; border-radius: 4px; padding: 4px; color: #333333; }
    QComboBox QAbstractItemView { background-color: #ffffff; border: 1px solid #d1d1d6; selection-background-color: #e5f1ff; color: #333333; }
    
    QToolTip { background-color: #ffffff; color: #333333; border: 1px solid #d1d1d6; padding: 4px; }
"""

# ===================|===================
main.py
# -*- coding: utf-8 -*-
import sys
import logging
import traceback
from PyQt5.QtWidgets import QApplication
from PyQt5.QtCore import Qt

# é…ç½®æ—¥å¿—åˆ°æ§åˆ¶å°
logging.basicConfig(level=logging.DEBUG, format='%(asctime)s [%(levelname)s] %(name)s: %(message)s')

def exception_hook(exctype, value, tb):
    error_msg = ''.join(traceback.format_exception(exctype, value, tb))
    logging.critical(f"å…¨å±€å¼‚å¸¸:\n{error_msg}")
    sys.__excepthook__(exctype, value, tb)

sys.excepthook = exception_hook

from main_window import ClipboardApp

def main():
    try:
        logging.info("ç¨‹åºå¯åŠ¨...")
        if hasattr(Qt, 'AA_EnableHighDpiScaling'):
            QApplication.setAttribute(Qt.AA_EnableHighDpiScaling, True)
        if hasattr(Qt, 'AA_UseHighDpiPixmaps'):
            QApplication.setAttribute(Qt.AA_UseHighDpiPixmaps, True)

        app = QApplication(sys.argv)
        app.setApplicationName("ClipboardManagerDark")
        
        # æ³¨æ„ï¼šè¿™é‡Œä¸å†è®¾ç½®å…¨å±€æ ·å¼è¡¨ï¼Œ
        # å› ä¸ºæ ·å¼ç°åœ¨ç”± main_window.py ä¸­çš„ apply_theme() æ–¹æ³•è´Ÿè´£åŠ è½½ã€‚
        
        window = ClipboardApp()
        window.show()
        
        logging.info("è¿›å…¥ä¸»å¾ªç¯")
        sys.exit(app.exec_())
    except Exception as e:
        logging.critical(f"Main Loop å´©æºƒ: {e}", exc_info=True)

if __name__ == "__main__":
    main()

# ===================|===================
main_window.py
ï»¿# -*- coding: utf-8 -*-
import sys
import ctypes
import logging
from ctypes.wintypes import MSG
from datetime import datetime
from PyQt5.QtWidgets import (QApplication, QMainWindow, QWidget, QVBoxLayout, 
                             QHBoxLayout, QPushButton, QLabel, QLineEdit, 
                             QTableWidgetItem, QHeaderView, QComboBox, 
                             QAbstractItemView, QShortcut, QMessageBox, QTextEdit, 
                             QMenu, QFrame, QScrollArea, QDockWidget, QSplitter, 
                             QCheckBox, QSizeGrip)
from PyQt5.QtGui import QKeySequence, QColor, QIcon, QPainter, QPixmap
from PyQt5.QtCore import Qt, pyqtSlot, QSettings, QPoint, QTimer

from database import DBManager, ClipboardItem
from widgets import DraggableTableWidget, HistoryLineEdit, ModernFilterBar 
from dialogs import TagSelectorDialog, AdvancedFilterDialog, ColorSelectorDialog
from theme_manager import ThemeManager

log = logging.getLogger("MainWindow")

class ClipboardApp(QMainWindow):
    def __init__(self):
        super().__init__()
        log.info("åˆå§‹åŒ–ä¸»çª—å£...")
        try:
            # 1. ä¼˜å…ˆåˆå§‹åŒ–å®šæ—¶å™¨
            self.save_timer = QTimer()
            self.save_timer.setSingleShot(True)
            self.save_timer.timeout.connect(self.save_window_state)
            self.save_timer.setInterval(500)

            # 2. åˆå§‹åŒ–æ ¸å¿ƒç»„ä»¶
            self.db = DBManager()
            self.theme_manager = ThemeManager()
            
            # 3. åŸºç¡€çŠ¶æ€å˜é‡
            self.last_clipboard_text = ""
            self.monitor_enabled = True
            self.selected_tags = set()
            self.advanced_filters = {}
            self.edit_mode = False
            self.used_colors = set()
            self.col_alignments = {} 
            self.current_item_tags = set()

            # 4. çª—å£è®¾ç½®
            self.setWindowTitle("å°è±¡è®°å¿†_Plus")
            self.resize(1300, 850)
            self.setWindowFlags(Qt.FramelessWindowHint)
            self.setAttribute(Qt.WA_TranslucentBackground)
            self.resize_margin = 5

            # 5. UI å¸ƒå±€åˆå§‹åŒ–
            self.central_container = QWidget()
            self.central_container.setObjectName("centralContainer")
            self.setCentralWidget(self.central_container)
            self.central_layout = QVBoxLayout(self.central_container)
            self.central_layout.setContentsMargins(0, 0, 0, 0)
            self.central_layout.setSpacing(0)

            self.init_title_bar()
            self.init_top_bar()
            self.init_table()
            self.init_metadata_panel()
            self.init_tag_panel()
            
            # 6. å³ä¸‹è§’è°ƒæ•´å¤§å°æ‰‹æŸ„
            self.size_grip = QSizeGrip(self.central_container)
            self.size_grip.setFixedSize(16, 16)
            self.size_grip.setStyleSheet("background: transparent;")
            self.size_grip.raise_()

            # 7. æ¢å¤æ•°æ®
            self.restore_window_state()
            self.load_data()

            # 8. å‰ªè´´æ¿ç›‘å¬
            self.clipboard = QApplication.clipboard()
            self.clipboard.dataChanged.connect(self.on_clipboard_change)
            
            # 9. å¿«æ·é”®
            self.group_shortcut = QShortcut(QKeySequence("Ctrl+G"), self)
            self.group_shortcut.activated.connect(self.group_selected_items)
            
            # 10. ç„¦ç‚¹è¿½è¸ª
            self.last_external_hwnd = None
            self.focus_timer = QTimer()
            self.focus_timer.timeout.connect(self.track_active_window)
            self.focus_timer.start(200)
            
            log.info("ä¸»çª—å£åˆå§‹åŒ–å®Œæˆ")
        except Exception as e:
            log.critical(f"Main Window Init Error: {e}", exc_info=True)
            raise e

    def track_active_window(self):
        """è¿½è¸ªå¤–éƒ¨çª—å£ç„¦ç‚¹"""
        try:
            hwnd = ctypes.windll.user32.GetForegroundWindow()
            if hwnd and hwnd != int(self.winId()): 
                self.last_external_hwnd = hwnd
        except: pass

    def nativeEvent(self, eventType, message):
        """å¤„ç†æ— è¾¹æ¡†çª—å£æ‹–æ‹½å’Œè°ƒæ•´å¤§å°"""
        try:
            if eventType == "windows_generic_MSG":
                msg = MSG.from_address(message.__int__())
                if msg.message == 0x0084: # WM_NCHITTEST
                    x = msg.lParam & 0xFFFF
                    y = msg.lParam >> 16
                    pos = self.mapFromGlobal(QPoint(x, y))
                    x = pos.x()
                    y = pos.y()
                    w = self.width()
                    h = self.height()
                    m = self.resize_margin
                    
                    is_left = x < m
                    is_right = x > w - m
                    is_top = y < m
                    is_bottom = y > h - m
                    
                    if is_top and is_left: return True, 13
                    if is_top and is_right: return True, 14
                    if is_bottom and is_left: return True, 16
                    if is_bottom and is_right: return True, 17
                    if is_left: return True, 10
                    if is_right: return True, 11
                    if is_top: return True, 12
                    if is_bottom: return True, 15
                    
                    if self.title_bar.geometry().contains(pos):
                        child = self.childAt(pos)
                        if child == self.title_bar or isinstance(child, QLabel): 
                            return True, 2
        except: pass
        return super().nativeEvent(eventType, message)

    def keyPressEvent(self, event):
        """å¤„ç†é”®ç›˜äº‹ä»¶"""
        mods = event.modifiers()
        key = event.key()
        core_mods = mods & ~Qt.KeypadModifier

        if core_mods == Qt.ControlModifier:
            if Qt.Key_0 <= key <= Qt.Key_5:
                lvl = key - Qt.Key_0
                if rows := self.table.selectionModel().selectedRows():
                    ids = [int(self.table.item(r.row(), 9).text()) for r in rows]
                    self.batch_set_star(ids, lvl)
                    event.accept()
                    return
        super().keyPressEvent(event)

    def init_title_bar(self):
        """åˆå§‹åŒ–æ ‡é¢˜æ """
        self.title_bar = QWidget()
        self.title_bar.setObjectName("titleBar")
        self.title_bar.setFixedHeight(36)
        layout = QHBoxLayout(self.title_bar)
        layout.setContentsMargins(5, 0, 5, 0)
        layout.setSpacing(10)
        
        layout.addWidget(QLabel("ğŸ’¾"))
        layout.addWidget(QLabel("å°è±¡è®°å¿†"))
        layout.addStretch()

        # åŠŸèƒ½æŒ‰é’®
        for text, tip, func in [("ğŸ”„", "åˆ·æ–°", lambda: self.load_data()), ("ğŸ—‘ï¸", "æ¸…ç†", self.auto_delete_old_items)]:
            btn = QPushButton(text)
            btn.setObjectName("titleBarButton")
            btn.setFixedSize(32, 32)
            btn.setToolTip(tip)
            btn.clicked.connect(func)
            layout.addWidget(btn)

        # ç½®é¡¶æŒ‰é’®
        self.btn_pin = QPushButton("ğŸ“Œ")
        self.btn_pin.setObjectName("titleBarButton")
        self.btn_pin.setFixedSize(32, 32)
        self.btn_pin.setCheckable(True)
        self.btn_pin.clicked.connect(self.toggle_always_on_top)
        layout.addWidget(self.btn_pin)

        # ä¸»é¢˜åˆ‡æ¢
        self.btn_theme = QPushButton("ğŸ¨")
        self.btn_theme.setObjectName("titleBarButton")
        self.btn_theme.setFixedSize(32, 32)
        self.btn_theme.setToolTip("åˆ‡æ¢ä¸»é¢˜")
        self.btn_theme.clicked.connect(self.toggle_theme)
        layout.addWidget(self.btn_theme)

        # é¢œè‰²è®¾ç½®
        btn_clr = QPushButton("ğŸŒˆ")
        btn_clr.setObjectName("titleBarButton")
        btn_clr.setFixedSize(32, 32)
        btn_clr.setToolTip("è®¾ç½®æ ‡ç­¾é¢œè‰²")
        btn_clr.clicked.connect(self.toolbar_set_color)
        layout.addWidget(btn_clr)

        # æ¨¡å¼åˆ‡æ¢
        self.mode_btn = QPushButton("ğŸ“–")
        self.mode_btn.setObjectName("titleBarButton")
        self.mode_btn.setFixedSize(32, 32)
        self.mode_btn.setCheckable(True)
        self.mode_btn.clicked.connect(self.toggle_edit_mode)
        layout.addWidget(self.mode_btn)

        layout.addWidget(QLabel("|"))

        # çª—å£æ§åˆ¶æŒ‰é’®
        b_min = QPushButton("â€”")
        b_min.setObjectName("minimizeButton")
        b_min.setFixedSize(32, 32)
        b_min.clicked.connect(self.showMinimized)
        
        self.btn_max = QPushButton("âƒ")
        self.btn_max.setObjectName("maximizeButton")
        self.btn_max.setFixedSize(32, 32)
        self.btn_max.clicked.connect(self.toggle_maximize)
        
        b_cls = QPushButton("âœ•")
        b_cls.setObjectName("closeButton")
        b_cls.setFixedSize(32, 32)
        b_cls.clicked.connect(self.close)
        
        layout.addWidget(b_min)
        layout.addWidget(self.btn_max)
        layout.addWidget(b_cls)
        self.central_layout.addWidget(self.title_bar)

    def init_top_bar(self):
        """åˆå§‹åŒ–ç­›é€‰æ """
        top_frame = QFrame()
        top_frame.setFixedHeight(50) 
        layout = QHBoxLayout(top_frame)
        layout.setContentsMargins(10, 5, 10, 5)
        layout.setSpacing(10)
        
        # 1. ç°ä»£åŒ–ç­›é€‰æ  (å«æœç´¢æ¡†)
        self.filter_bar = ModernFilterBar()
        self.filter_bar.filterChanged.connect(self.load_data)
        layout.addWidget(self.filter_bar)
        
        # 2. æ’åº
        layout.addWidget(QLabel("æ’åº:"))
        self.sort_combo = QComboBox()
        self.sort_combo.addItems(["âœ‹ æ‰‹åŠ¨", "ğŸ•’ æ—¶é—´", "ğŸ’¾ å¤§å°", "ğŸ”¥ çƒ­åº¦", "â­ æ˜Ÿçº§"])
        self.sort_map = {0: "manual", 1: "time_desc", 2: "size_desc", 3: "visit_desc", 4: "stars_desc"}
        self.sort_combo.currentIndexChanged.connect(self.load_data)
        layout.addWidget(self.sort_combo)
        
        self.central_layout.addWidget(top_frame)

    def init_table(self):
        self.table = DraggableTableWidget()
        cols = ["åº", "çŠ¶æ€", "å¤‡æ³¨", "æ˜Ÿçº§", "å¤§å°", "è®¿é—®", "åˆ›å»ºæ—¶é—´", "è®¿é—®æ—¶é—´", "å†…å®¹", "ID"]
        self.table.setColumnCount(len(cols))
        self.table.setHorizontalHeaderLabels(cols)
        self.table.setColumnHidden(9, True)
        
        w = self.table.setColumnWidth
        w(0, 40); w(1, 50); w(2, 120); w(3, 60); w(4, 70); w(5, 40); w(6, 140); w(7, 140)
        self.table.horizontalHeader().setSectionResizeMode(8, QHeaderView.Stretch)
        self.table.verticalHeader().setVisible(False)
        self.table.setContextMenuPolicy(Qt.CustomContextMenu)
        self.table.customContextMenuRequested.connect(self.show_context_menu)
        self.table.itemSelectionChanged.connect(self.update_dock_panel)
        self.table.itemDoubleClicked.connect(self.on_table_double_click)
        self.table.itemChanged.connect(self.on_item_changed)
        self.table.horizontalHeader().setContextMenuPolicy(Qt.CustomContextMenu)
        self.table.horizontalHeader().customContextMenuRequested.connect(self.show_header_menu)
        self.table.horizontalHeader().sectionResized.connect(self.on_column_resized)
        self.table.doubleClicked.connect(self.paste_to_previous_window)
        self.table.setAlternatingRowColors(True)
        self.central_layout.addWidget(self.table)

    def init_metadata_panel(self):
        self.metadata_dock = QDockWidget("ğŸ“Š å…ƒæ•°æ®", self)
        self.metadata_dock.setAllowedAreas(Qt.LeftDockWidgetArea | Qt.RightDockWidgetArea | Qt.BottomDockWidgetArea)
        c = QWidget()
        # èƒŒæ™¯è‰²ç”±ä¸»é¢˜æ¥ç®¡
        l = QVBoxLayout(c)
        spl = QSplitter(Qt.Vertical)
        
        self.preview_text = QTextEdit()
        self.preview_text.setReadOnly(True)
        self.preview_text.setMinimumHeight(100)
        spl.addWidget(self.preview_text)
        
        bw = QWidget()
        bl = QVBoxLayout(bw)
        btn = QPushButton("æå–å†…å®¹")
        btn.clicked.connect(self.extract_content)
        bl.addWidget(btn)
        bl.addSpacing(15)
        bl.addWidget(QLabel("ğŸ“ å¤‡æ³¨"))
        self.note_input = QLineEdit()
        self.note_input.returnPressed.connect(self.save_note)
        bl.addWidget(self.note_input)
        bl.addStretch()
        
        spl.addWidget(bw)
        l.addWidget(spl)
        self.metadata_dock.setWidget(c)
        self.addDockWidget(Qt.RightDockWidgetArea, self.metadata_dock)
        self.metadata_dock.dockLocationChanged.connect(self.schedule_save_window_state)
    
    def init_tag_panel(self):
        self.tag_dock = QDockWidget("ğŸ·ï¸ æ ‡ç­¾", self)
        self.tag_dock.setAllowedAreas(Qt.LeftDockWidgetArea | Qt.RightDockWidgetArea | Qt.BottomDockWidgetArea)
        c = QWidget()
        l = QVBoxLayout(c)
        
        l.addWidget(QLabel("å½“å‰æ ‡ç­¾:"))
        self.cur_tag_area = QWidget()
        self.cur_tag_layout = QHBoxLayout(self.cur_tag_area)
        self.cur_tag_layout.setAlignment(Qt.AlignLeft)
        l.addWidget(self.cur_tag_area)
        l.addSpacing(15)
        
        l.addWidget(QLabel("ğŸ“š æ ‡ç­¾åº“ (ç‚¹å‡»ä¸ºé€‰ä¸­é¡¹æ‰“æ ‡):"))
        self.tag_scroll = QScrollArea()
        self.tag_scroll.setWidgetResizable(True)
        self.tag_cont = QWidget()
        self.tag_cloud_layout = QVBoxLayout(self.tag_cont)
        self.tag_cloud_layout.setAlignment(Qt.AlignTop)
        self.tag_scroll.setWidget(self.tag_cont)
        l.addWidget(self.tag_scroll)
        
        btn = QPushButton("+ æ–°å»ºæ ‡ç­¾")
        btn.clicked.connect(self.add_tag_action)
        l.addWidget(btn)
        self.tag_dock.setWidget(c)
        self.addDockWidget(Qt.RightDockWidgetArea, self.tag_dock)
        self.tag_dock.dockLocationChanged.connect(self.schedule_save_window_state)

    def load_data(self, select_id=None):
        try:
            self.table.blockSignals(True)
            
            # è¯»å–ç­›é€‰æ 
            filter_state = self.filter_bar.get_filters()
            filters = {
                'is_favorite': filter_state['is_favorite'],
                'is_locked': filter_state['is_locked'],
                'is_file': filter_state['is_file'],
                'star_levels': filter_state['star_levels'],
                'date_created': filter_state['date_created'],
                'date_modified': filter_state['date_modified']
            }
            search = filter_state['search']
            
            sort = self.sort_map.get(self.sort_combo.currentIndex(), "manual")
            items = self.db.get_all_items(filters, search, sort, self.selected_tags)
            
            self.table.setRowCount(0)
            select_row = -1
            
            for i, item in enumerate(items):
                self.insert_row(item, i+1)
                if select_id and item.id == select_id: select_row = i
            
            self.refresh_tag_cloud()
            
            if select_row >= 0: 
                self.table.selectRow(select_row)
                self.table.scrollToItem(self.table.item(select_row, 0))
        except Exception as e: 
            log.error(f"Load Data Error: {e}")
        finally: 
            self.table.blockSignals(False)

    def insert_row(self, item, idx):
        r = self.table.rowCount()
        self.table.insertRow(r)
        
        # 0. åºå·
        seq_item = QTableWidgetItem(str(idx))
        seq_item.setTextAlignment(self.col_alignments.get(0, Qt.AlignCenter))
        self.table.setItem(r, 0, seq_item)
        
        # 1. çŠ¶æ€
        st = ""
        if item.is_pinned: st += "ğŸ“Œ"
        if item.is_favorite: st += "â¤ï¸"
        if item.is_locked: st += "ğŸ”’"
        si = QTableWidgetItem(st)
        
        c = item.custom_color or item.group_color
        if c: si.setIcon(self.create_color_icon(c))
        si.setTextAlignment(self.col_alignments.get(1, Qt.AlignCenter))
        self.table.setItem(r, 1, si)
        
        # 2. å¤‡æ³¨
        note = f"ğŸ“„ {item.note}" if item.is_file else item.note
        note_item = QTableWidgetItem(note)
        note_item.setTextAlignment(self.col_alignments.get(2, Qt.AlignLeft | Qt.AlignVCenter))
        self.table.setItem(r, 2, note_item)
        
        # 3. æ˜Ÿçº§
        star = QTableWidgetItem("â˜…" * item.star_level)
        star.setTextAlignment(self.col_alignments.get(3, Qt.AlignCenter))
        star.setForeground(QColor("#FFD700"))
        self.table.setItem(r, 3, star)
        
        # 4. å¤§å°
        size_item = QTableWidgetItem(self.format_size(item.content))
        size_item.setTextAlignment(self.col_alignments.get(4, Qt.AlignRight | Qt.AlignVCenter))
        self.table.setItem(r, 4, size_item)
        
        # 5. è®¿é—®
        visit_item = QTableWidgetItem(str(item.visit_count))
        visit_item.setTextAlignment(self.col_alignments.get(5, Qt.AlignCenter))
        self.table.setItem(r, 5, visit_item)
        
        # 6. æ—¶é—´
        time_item = QTableWidgetItem(item.created_at.strftime("%Y-%m-%d %H:%M:%S"))
        time_item.setTextAlignment(self.col_alignments.get(6, Qt.AlignLeft | Qt.AlignVCenter))
        self.table.setItem(r, 6, time_item)
        
        # 7. è®¿é—®æ—¶é—´
        vtime_item = QTableWidgetItem(item.last_visited_at.strftime("%Y-%m-%d %H:%M:%S") if item.last_visited_at else "")
        vtime_item.setTextAlignment(self.col_alignments.get(7, Qt.AlignLeft | Qt.AlignVCenter))
        self.table.setItem(r, 7, vtime_item)
        
        # 8. å†…å®¹
        cnt = f"[æ–‡ä»¶] {item.content}" if item.is_file else item.content
        content_item = QTableWidgetItem(cnt[:60].replace('\n', ' '))
        content_item.setTextAlignment(self.col_alignments.get(8, Qt.AlignLeft | Qt.AlignVCenter))
        self.table.setItem(r, 8, content_item)
        
        # 9. ID
        self.table.setItem(r, 9, QTableWidgetItem(str(item.id)))

    def format_size(self, t):
        b = len(t.encode('utf-8'))
        return f"{b} B" if b < 1024 else f"{b/1024:.1f} KB" if b < 1024**2 else f"{b/1024**2:.1f} MB"

    def create_color_icon(self, hex):
        px = QPixmap(16, 16)
        px.fill(Qt.transparent)
        p = QPainter(px)
        p.setRenderHint(QPainter.Antialiasing)
        p.setBrush(QColor(hex))
        p.setPen(Qt.NoPen)
        p.drawEllipse(0, 0, 16, 16)
        p.end()
        return QIcon(px)

    def clear_filters(self):
        self.advanced_filters = {}
        self.filter_bar.reset_filters()

    def open_advanced_filter_dialog(self):
        # æ³¨æ„: è¿™é‡Œçš„ 'é«˜çº§ç­›é€‰' æŒ‰é’®åœ¨ç•Œé¢ä¸Šå·²ç»ç§»é™¤ï¼Œä¿ç•™æ­¤å‡½æ•°ä»…ä¸ºå…¼å®¹æ—§é€»è¾‘
        pass

    def show_context_menu(self, pos):
        if not self.table.indexAt(pos).isValid(): return
        
        rows = self.table.selectionModel().selectedRows()
        if not rows: return
        item_ids = [int(self.table.item(r.row(), 9).text()) for r in rows]
        is_batch = len(item_ids) > 1

        menu = QMenu()
        
        # 1. æ˜Ÿçº§èœå•
        sm = menu.addMenu("â­ è®¾ç½®æ˜Ÿçº§")
        for i in range(6): 
            sm.addAction(["æ— ", "â˜…", "â˜…â˜…", "â˜…â˜…â˜…", "â˜…â˜…â˜…â˜…", "â˜…â˜…â˜…â˜…â˜…"][i]).triggered.connect(lambda _, l=i, x=item_ids: self.batch_set_star(x, l))
        
        menu.addSeparator()

        # 2. çŠ¶æ€æ“ä½œ
        if is_batch:
            menu.addAction(f"â¤ï¸ æ”¶è—/å–æ¶ˆ ({len(item_ids)})").triggered.connect(lambda: self.batch_toggle_field(item_ids, 'is_favorite'))
            menu.addAction(f"ğŸ“Œ ç½®é¡¶/å–æ¶ˆ ({len(item_ids)})").triggered.connect(lambda: self.batch_toggle_field(item_ids, 'is_pinned'))
            menu.addAction(f"ğŸ”’ é”å®š/è§£é” ({len(item_ids)})").triggered.connect(lambda: self.batch_toggle_field(item_ids, 'is_locked'))
        else:
            s = self.db.get_session()
            if x := s.query(ClipboardItem).get(item_ids[0]):
                menu.addAction("â¤ï¸ å–æ¶ˆæ”¶è—" if x.is_favorite else "â¤ï¸ æ”¶è—").triggered.connect(lambda: self.batch_toggle_field(item_ids, 'is_favorite'))
                menu.addAction("ğŸ“Œ å–æ¶ˆç½®é¡¶" if x.is_pinned else "ğŸ“Œ ç½®é¡¶").triggered.connect(lambda: self.batch_toggle_field(item_ids, 'is_pinned'))
                menu.addAction("ğŸ”’ è§£é”" if x.is_locked else "ğŸ”’ é”å®š").triggered.connect(lambda: self.batch_toggle_field(item_ids, 'is_locked'))
            s.close()

        menu.addSeparator()
        
        # 3. é¢œè‰²èœå•
        cm = menu.addMenu("ğŸ¨ é¢œè‰²æ ‡ç­¾")
        c1 = cm.addMenu("å¸¸ç”¨é¢œè‰²æ ‡ç­¾")
        for n, c in [("ç´§æ€¥", "#f38ba8"), ("é‡è¦", "#f9e2af"), ("é€šè¿‡", "#a6e3a1"), ("å‚è€ƒ", "#89b4fa"), ("ä¸ªäºº", "#cba6f7"), ("å­˜æ¡£", "#585b70")]:
            a = c1.addAction(n)
            a.setIcon(self.create_color_icon(c))
            a.triggered.connect(lambda _, cl=c, x=item_ids: self.batch_set_color(x, cl))
            
        c2 = cm.addMenu("æ”¶è—é¢œè‰²æ ‡ç­¾")
        if favs := QSettings("ClipboardApp", "ColorFavorites").value("favorite_colors", [], type=list):
            for c in favs: 
                a = c2.addAction(c.upper())
                a.setIcon(self.create_color_icon(c))
                a.triggered.connect(lambda _, cl=c, x=item_ids: self.batch_set_color(x, cl))
        else: 
            c2.setEnabled(False)
        
        c3 = cm.addMenu("å†å²é¢œè‰²æ ‡ç­¾")
        if hists := QSettings("ClipboardApp", "ColorHistory").value("colors", []):
            for c in hists[:10]: 
                a = c3.addAction(c.upper())
                a.setIcon(self.create_color_icon(c))
                a.triggered.connect(lambda _, cl=c, x=item_ids: self.batch_set_color(x, cl))
        else: 
            c3.setEnabled(False)
            
        menu.addAction("ğŸ¨ è‡ªå®šä¹‰é¢œè‰²...").triggered.connect(lambda: self.set_custom_color(item_ids))
        menu.addAction("ç§»é™¤é¢œè‰²æ ‡ç­¾").triggered.connect(lambda: self.batch_set_color(item_ids, None))
        
        menu.addSeparator()
        menu.addAction(f"âŒ åˆ é™¤ ({len(item_ids)}é¡¹)").triggered.connect(lambda: self.batch_delete(item_ids))
        
        menu.exec_(self.table.mapToGlobal(pos))

    def batch_set_star(self, ids, lvl):
        s = self.db.get_session()
        for i in ids:
            if x := s.query(ClipboardItem).get(i): x.star_level = lvl
        s.commit()
        s.close()
        self.load_data(select_id=ids[0] if ids else None)

    def batch_toggle_field(self, ids, fld):
        s = self.db.get_session()
        for i in ids:
            if x := s.query(ClipboardItem).get(i): setattr(x, fld, not getattr(x, fld))
        s.commit()
        s.close()
        self.load_data(select_id=ids[0] if ids else None)
    
    def batch_set_color(self, ids, clr):
        s = self.db.get_session()
        for i in ids:
            if x := s.query(ClipboardItem).get(i): x.custom_color = clr
        s.commit()
        s.close()
        self.load_data(select_id=ids[0] if ids else None)

    def batch_delete(self, ids):
        if QMessageBox.question(self, "ç¡®è®¤", f"åˆ é™¤ {len(ids)} é¡¹?") == QMessageBox.Yes:
            s = self.db.get_session()
            for i in ids:
                if x := s.query(ClipboardItem).get(i):
                    if not x.is_locked: s.delete(x)
            s.commit()
            s.close()
            self.load_data()

    def show_header_menu(self, pos):
        c = self.table.horizontalHeader().logicalIndexAt(pos)
        m = QMenu()
        m.addAction("â† å·¦å¯¹é½").triggered.connect(lambda: self.set_col_align(c, Qt.AlignLeft | Qt.AlignVCenter))
        m.addAction("â†” å±…ä¸­").triggered.connect(lambda: self.set_col_align(c, Qt.AlignCenter))
        m.addAction("â†’ å³å¯¹é½").triggered.connect(lambda: self.set_col_align(c, Qt.AlignRight | Qt.AlignVCenter))
        m.exec_(self.table.horizontalHeader().mapToGlobal(pos))
    
    def set_col_align(self, c, a):
        for r in range(self.table.rowCount()): 
            self.table.item(r, c).setTextAlignment(a)
        self.col_alignments[c] = int(a)
        QSettings("ClipboardApp", "WindowState").setValue(f"col_{c}_align", int(a))

    @pyqtSlot()
    def on_clipboard_change(self):
        if not self.monitor_enabled: return
        try:
            m = self.clipboard.mimeData()
            if m.hasUrls():
                files = [u.toLocalFile() for u in m.urls() if u.isLocalFile()]
                if files:
                    t = "\n".join(files)
                    if t != self.last_clipboard_text:
                        self.last_clipboard_text = t
                        for f in files: self.db.add_item(text=f, is_file=True, file_path=f)
                        if self.sort_combo.currentIndex() == 0: self.load_data()
            elif m.hasText():
                t = m.text().strip()
                if t and t != self.last_clipboard_text:
                    self.last_clipboard_text = t
                    self.db.add_item(t)
                    if self.sort_combo.currentIndex() == 0: self.load_data()
        except: pass

    def toggle_edit_mode(self):
        self.edit_mode = not self.edit_mode
        self.mode_btn.setChecked(self.edit_mode)
        self.table.setEditTriggers(QAbstractItemView.DoubleClicked if self.edit_mode else QAbstractItemView.NoEditTriggers)
        self.table.setDragEnabled(self.edit_mode)

    def on_table_double_click(self, item):
        if not self.edit_mode:
            if id_item := self.table.item(item.row(), 9):
                s = self.db.get_session()
                if x := s.query(ClipboardItem).get(int(id_item.text())):
                    self.monitor_enabled = False
                    self.clipboard.setText(x.content)
                    self.monitor_enabled = True
                    self.statusBar().showMessage("âœ… å·²å¤åˆ¶")
                s.close()

    def on_item_changed(self, item):
        if self.edit_mode and (id_item := self.table.item(item.row(), 9)) and (fld := {2: 'note', 8: 'content'}.get(item.column())):
            self.db.update_field(int(id_item.text()), fld, item.text().strip())

    def update_dock_panel(self):
        sel = self.table.selectedItems()
        self.current_item_tags.clear()
        if not sel: 
            self.preview_text.clear()
            self.note_input.clear()
            self.current_id = None
            self.refresh_tag_cloud()
            return
            
        s = self.db.get_session()
        item_id = int(self.table.item(sel[0].row(), 9).text())
        if x := s.query(ClipboardItem).get(item_id):
            self.current_id = x.id
            self.preview_text.setText(f"[æ–‡ä»¶]\nè·¯å¾„: {item.file_path}" if x.is_file else x.content)
            self.note_input.setText(x.note)
            self.current_item_tags = {t.name for t in x.tags}
            self.render_current_tags(x.tags)
            self.refresh_tag_cloud()
        s.close()

    def render_current_tags(self, tags):
        for i in reversed(range(self.cur_tag_layout.count())): 
            if w := self.cur_tag_layout.itemAt(i).widget(): w.setParent(None)
        for t in tags:
            b = QPushButton(f"{t.name} âœ–")
            b.setStyleSheet("color: #89b4fa; border: 1px solid #89b4fa; border-radius: 10px;")
            b.clicked.connect(lambda _, n=t.name: self.del_tag(n))
            self.cur_tag_layout.addWidget(b)

    def refresh_tag_cloud(self):
        for i in reversed(range(self.tag_cloud_layout.count())): 
            if w := self.tag_cloud_layout.itemAt(i).widget(): w.setParent(None)
        for n, c in self.db.get_tag_cloud():
            b = QPushButton(f"ğŸ·ï¸ {n}  ({c})")
            b.setCheckable(True)
            if self.current_item_tags and n in self.current_item_tags: 
                b.setChecked(True)
                b.setStyleSheet("background-color: #89b4fa; color: #1e1e2e; font-weight: bold;")
            b.clicked.connect(lambda _, t=n: self.toggle_tag_on_selection(t))
            self.tag_cloud_layout.addWidget(b)

    def toggle_tag_on_selection(self, t):
        if not hasattr(self, 'current_id') or not self.current_id: return
        rows = self.table.selectionModel().selectedRows()
        ids = [int(self.table.item(r.row(), 9).text()) for r in rows]
        if t not in self.current_item_tags: 
            self.db.add_tags_to_items(ids, t)
        else: 
            for i in ids: self.db.remove_tag_from_item(i, t)
        self.update_dock_panel()

    def del_tag(self, n):
        if hasattr(self, 'current_id'): 
            self.db.remove_tag_from_item(self.current_id, n)
            self.update_dock_panel()

    def add_tag_action(self):
        if hasattr(self, 'current_id'): TagSelectorDialog(self.db, self.current_id, self).show()

    def save_note(self):
        if hasattr(self, 'current_id'):
            self.db.update_field(self.current_id, 'note', self.note_input.text())
            if self.table.currentRow() >= 0: self.table.item(self.table.currentRow(), 2).setText(self.note_input.text())

    def extract_content(self):
        self.monitor_enabled = False
        self.clipboard.setText(self.preview_text.toPlainText())
        self.monitor_enabled = True

    def update_db_order(self, ids):
        if self.sort_combo.currentIndex() != 0: 
            QMessageBox.warning(self, "æç¤º", "è¯·åˆ‡æ¢åˆ°'æ‰‹åŠ¨æ‹–æ‹½'æ¨¡å¼")
            self.load_data()
            return
        self.db.update_sort_order(ids)

    def toggle_always_on_top(self):
        on = self.btn_pin.isChecked()
        self.setWindowFlags(self.windowFlags() | Qt.WindowStaysOnTopHint if on else self.windowFlags() & ~Qt.WindowStaysOnTopHint)
        self.btn_pin.setStyleSheet("background-color: #45475a;" if on else "")
        self.show()

    def toggle_maximize(self):
        if self.isMaximized(): 
            self.showNormal()
            self.btn_max.setText("âƒ")
        else: 
            self.showMaximized()
            self.btn_max.setText("â")

    def schedule_save_window_state(self): 
        self.save_timer.start()

    def save_window_state(self):
        s = QSettings("ClipboardApp", "WindowState")
        s.setValue("geometry", self.saveGeometry())
        s.setValue("windowState", self.saveState())
        s.setValue("editMode", self.edit_mode)
        s.setValue("columnWidths", [self.table.columnWidth(i) for i in range(self.table.columnCount())])
        s.setValue("current_theme", self.current_theme)

    def restore_window_state(self):
        s = QSettings("ClipboardApp", "WindowState")
        if g := s.value("geometry"): self.restoreGeometry(g)
        if ws := s.value("windowState"): self.restoreState(ws)
        if em := s.value("editMode", False, type=bool): 
            self.edit_mode = True
            self.mode_btn.setChecked(True)
            self.table.setEditTriggers(QAbstractItemView.DoubleClicked)
        if cw := s.value("columnWidths"):
            for i, w in enumerate(cw): self.table.setColumnWidth(i, int(w))
        
        for i in range(self.table.columnCount()):
            if align := s.value(f"col_{i}_align"):
                self.col_alignments[i] = int(align)
        
        self.current_theme = s.value("current_theme", "dark")
        self.apply_theme(self.current_theme)

    def toggle_theme(self):
        current_name = self.current_theme if hasattr(self, 'current_theme') else "dark"
        next_theme = self.theme_manager.get_next_theme_name(current_name)
        if next_theme:
            self.apply_theme(next_theme)
            self.schedule_save_window_state()

    def apply_theme(self, theme_name):
        module = self.theme_manager.get_theme(theme_name)
        if not module: 
            log.warning(f"ä¸»é¢˜ {theme_name} æœªæ‰¾åˆ°ï¼Œå°è¯•åŠ è½½é»˜è®¤ dark")
            module = self.theme_manager.get_theme("dark")
            theme_name = "dark"
        
        if module and hasattr(module, 'STYLESHEET'):
            self.current_theme = theme_name
            QApplication.instance().setStyleSheet(module.STYLESHEET)
            log.info(f"åˆ‡æ¢ä¸»é¢˜ä¸º: {theme_name}")

    def on_column_resized(self, *args): self.schedule_save_window_state()
    def closeEvent(self, e): self.save_window_state(); e.accept()

    def group_selected_items(self):
        if not (rows := self.table.selectionModel().selectedRows()): return
        ids = [int(self.table.item(r.row(), 9).text()) for r in rows]
        s = self.db.get_session()
        has_c = any(s.query(ClipboardItem).get(i).group_color for i in ids)
        nc = None if has_c else "#2c5282"
        for i in ids: 
            if x := s.query(ClipboardItem).get(i): x.group_color = nc
        s.commit()
        s.close()
        self.load_data()

    def toolbar_set_color(self):
        if rows := self.table.selectionModel().selectedRows(): 
            self.set_custom_color([int(self.table.item(r.row(), 9).text()) for r in rows])

    def set_custom_color(self, ids):
        d = ColorSelectorDialog(self)
        if d.exec_(): self.batch_set_color(ids, d.selected_color if d.selected_color else None)

    def auto_delete_old_items(self):
        if QMessageBox.question(self, "ç¡®è®¤", "åˆ é™¤21å¤©å‰æœªé”å®šæ•°æ®?") == QMessageBox.Yes:
            c = self.db.auto_delete_old_data()
            QMessageBox.information(self, "å®Œæˆ", f"å·²åˆ é™¤ {c} æ¡")
            self.load_data()

    def paste_to_previous_window(self):
        if not self.last_external_hwnd: return
        r = self.table.currentRow()
        self.clipboard.setText(self.table.item(r, 8).text())
        try:
            ctypes.windll.user32.SetForegroundWindow(self.last_external_hwnd)
            if ctypes.windll.user32.IsIconic(self.last_external_hwnd): 
                ctypes.windll.user32.ShowWindow(self.last_external_hwnd, 9)
        except: pass
        self.showMinimized()
        QTimer.singleShot(150, lambda: [ctypes.windll.user32.keybd_event(k,0,f,0) for k,f in [(0x11,0),(0x56,0),(0x56,2),(0x11,2)]])

# ===================|===================
themes.py
ï»¿# -*- coding: utf-8 -*-

# === æ·±è‰²ä¸»é¢˜ (åŸç‰ˆ) ===
DARK_THEME = """
    QWidget { background-color: #1e1e2e; color: #cdd6f4; font-family: "Segoe UI", "Microsoft YaHei"; font-size: 13px; }
    QDialog, QMessageBox, QColorDialog { background-color: #1e1e2e; }
    QMessageBox QLabel { color: #cdd6f4; }
    
    QPushButton { background-color: #313244; border: 1px solid #45475a; border-radius: 4px; padding: 5px; color: #cdd6f4; }
    QPushButton:hover { background-color: #45475a; border-color: #89b4fa; }
    QPushButton:pressed { background-color: #89b4fa; color: #1e1e2e; }
    
    QLineEdit, QTextEdit, QPlainTextEdit, QSpinBox, QDateEdit {
        background-color: #11111b; border: 1px solid #313244; border-radius: 4px; padding: 4px; color: #cdd6f4; selection-background-color: #89b4fa; selection-color: #1e1e2e;
    }
    QLineEdit:focus, QTextEdit:focus { border: 1px solid #89b4fa; }
    
    QListWidget, QTableWidget, QTreeWidget {
        background-color: #11111b; border: 1px solid #313244; alternate-background-color: #181825; outline: none;
    }
    QHeaderView::section { background-color: #181825; color: #a6adc8; border: none; padding: 6px; font-weight: bold; border-right: 1px solid #313244; }
    QTableWidget::item:selected, QListWidget::item:selected { background-color: #313244; color: #89b4fa; border: none; }
    
    QScrollBar:vertical { background: #11111b; width: 12px; margin: 0; }
    QScrollBar::handle:vertical { background: #45475a; min-height: 20px; border-radius: 6px; margin: 2px; }
    QScrollBar::handle:vertical:hover { background: #585b70; }
    QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical { height: 0; }
    QScrollBar:horizontal { background: #11111b; height: 12px; margin: 0; }
    QScrollBar::handle:horizontal { background: #45475a; min-width: 20px; border-radius: 6px; margin: 2px; }
    QScrollBar::add-line:horizontal, QScrollBar::sub-line:horizontal { width: 0; }
    
    QMenu { background-color: #1e1e2e; border: 1px solid #45475a; padding: 5px; }
    QMenu::item { padding: 5px 20px; border-radius: 4px; }
    QMenu::item:selected { background-color: #313244; color: #89b4fa; }
    QMenu::separator { height: 1px; background: #45475a; margin: 5px 0; }
    
    QComboBox { background-color: #313244; border: 1px solid #45475a; border-radius: 4px; padding: 4px; }
    QComboBox::drop-down { border: none; }
    QComboBox QAbstractItemView { background-color: #1e1e2e; border: 1px solid #45475a; selection-background-color: #313244; color: #cdd6f4; }
    
    QCalendarWidget QWidget { background-color: #1e1e2e; color: #cdd6f4; }
    QCalendarWidget QToolButton { color: #cdd6f4; background-color: transparent; }
    QCalendarWidget QToolButton:hover { background-color: #313244; }
    QCalendarWidget QAbstractItemView:enabled { background-color: #11111b; color: #cdd6f4; selection-background-color: #89b4fa; selection-color: #1e1e2e; }
    
    QToolTip { background-color: #11111b; color: #cdd6f4; border: 1px solid #45475a; padding: 4px; }
"""

# === æµ…è‰²ä¸»é¢˜ (æ–°å¢) ===
LIGHT_THEME = """
    QWidget { background-color: #f5f5f7; color: #333333; font-family: "Segoe UI", "Microsoft YaHei"; font-size: 13px; }
    QDialog, QMessageBox, QColorDialog { background-color: #ffffff; }
    QMessageBox QLabel { color: #333333; }
    
    QPushButton { background-color: #ffffff; border: 1px solid #d1d1d6; border-radius: 4px; padding: 5px; color: #333333; }
    QPushButton:hover { background-color: #e5e5ea; border-color: #007aff; }
    QPushButton:pressed { background-color: #007aff; color: #ffffff; }
    
    QLineEdit, QTextEdit, QPlainTextEdit, QSpinBox, QDateEdit {
        background-color: #ffffff; border: 1px solid #d1d1d6; border-radius: 4px; padding: 4px; color: #333333; selection-background-color: #007aff; selection-color: #ffffff;
    }
    QLineEdit:focus, QTextEdit:focus { border: 1px solid #007aff; }
    
    QListWidget, QTableWidget, QTreeWidget {
        background-color: #ffffff; border: 1px solid #d1d1d6; alternate-background-color: #f2f2f7; outline: none;
    }
    QHeaderView::section { background-color: #e5e5ea; color: #333333; border: none; padding: 6px; font-weight: bold; border-right: 1px solid #d1d1d6; }
    QTableWidget::item:selected, QListWidget::item:selected { background-color: #e5f1ff; color: #007aff; border: none; }
    
    QScrollBar:vertical { background: #f5f5f7; width: 12px; margin: 0; }
    QScrollBar::handle:vertical { background: #c7c7cc; min-height: 20px; border-radius: 6px; margin: 2px; }
    QScrollBar::handle:vertical:hover { background: #aeaeb2; }
    QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical { height: 0; }
    QScrollBar:horizontal { background: #f5f5f7; height: 12px; margin: 0; }
    QScrollBar::handle:horizontal { background: #c7c7cc; min-width: 20px; border-radius: 6px; margin: 2px; }
    QScrollBar::add-line:horizontal, QScrollBar::sub-line:horizontal { width: 0; }
    
    QMenu { background-color: #ffffff; border: 1px solid #d1d1d6; padding: 5px; }
    QMenu::item { padding: 5px 20px; border-radius: 4px; color: #333333; }
    QMenu::item:selected { background-color: #e5f1ff; color: #007aff; }
    QMenu::separator { height: 1px; background: #d1d1d6; margin: 5px 0; }
    
    QComboBox { background-color: #ffffff; border: 1px solid #d1d1d6; border-radius: 4px; padding: 4px; color: #333333; }
    QComboBox::drop-down { border: none; }
    QComboBox QAbstractItemView { background-color: #ffffff; border: 1px solid #d1d1d6; selection-background-color: #e5f1ff; color: #333333; }
    
    QCalendarWidget QWidget { background-color: #ffffff; color: #333333; }
    QCalendarWidget QToolButton { color: #333333; background-color: transparent; }
    QCalendarWidget QToolButton:hover { background-color: #e5e5ea; }
    QCalendarWidget QAbstractItemView:enabled { background-color: #ffffff; color: #333333; selection-background-color: #007aff; selection-color: #ffffff; }
    
    QToolTip { background-color: #ffffff; color: #333333; border: 1px solid #d1d1d6; padding: 4px; }
"""

# ===================|===================
theme_manager.py
# theme_manager.py
# -*- coding: utf-8 -*-
import os
import sys
import importlib.util
import logging

log = logging.getLogger("ThemeManager")

class ThemeManager:
    def __init__(self):
        self.themes = {} # {filename_no_ext: module}
        self.load_themes()

    def load_themes(self):
        """æ‰«æ themes æ–‡ä»¶å¤¹å¹¶åŠ è½½æ‰€æœ‰ .py æ–‡ä»¶"""
        log.info("å¼€å§‹åŠ è½½ä¸»é¢˜...")
        # è·å– themes æ–‡ä»¶å¤¹è·¯å¾„
        if getattr(sys, 'frozen', False):
            base_dir = os.path.dirname(sys.executable)
        else:
            base_dir = os.path.dirname(os.path.abspath(__file__))
        
        theme_dir = os.path.join(base_dir, 'themes')
        
        if not os.path.exists(theme_dir):
            log.warning(f"ä¸»é¢˜æ–‡ä»¶å¤¹ä¸å­˜åœ¨: {theme_dir}")
            return

        for filename in os.listdir(theme_dir):
            if filename.endswith(".py") and filename != "__init__.py":
                theme_name = filename[:-3]
                try:
                    file_path = os.path.join(theme_dir, filename)
                    spec = importlib.util.spec_from_file_location(f"themes.{theme_name}", file_path)
                    module = importlib.util.module_from_spec(spec)
                    spec.loader.exec_module(module)
                    
                    if hasattr(module, 'STYLESHEET'):
                        self.themes[theme_name] = module
                        log.info(f"ä¸»é¢˜åŠ è½½æˆåŠŸ: {theme_name}")
                except Exception as e:
                    log.error(f"åŠ è½½ä¸»é¢˜ {filename} å¤±è´¥: {e}")

    def get_theme(self, theme_name):
        return self.themes.get(theme_name)

    def get_available_themes(self):
        return list(self.themes.keys())
    
    def get_next_theme_name(self, current_name):
        """å¾ªç¯åˆ‡æ¢ä¸»é¢˜"""
        keys = list(self.themes.keys())
        if not keys: return None
        if current_name not in keys: return keys[0]
        
        idx = keys.index(current_name)
        next_idx = (idx + 1) % len(keys)
        return keys[next_idx]

# ===================|===================
widgets.py
ï»¿# -*- coding: utf-8 -*-
import logging
from datetime import datetime, timedelta, time
from PyQt5.QtWidgets import (QTableWidget, QAbstractItemView, QLineEdit, QListWidget, 
                             QListWidgetItem, QWidget, QVBoxLayout, QHBoxLayout, 
                             QPushButton, QFrame, QLabel, QMenu, QAction, QScrollArea,
                             QDialog, QDateEdit, QDialogButtonBox)
from PyQt5.QtCore import Qt, QSettings, QSize, pyqtSignal, QEvent, QTimer, QDate
from PyQt5.QtGui import QFont, QCursor, QColor

log = logging.getLogger("Widgets")

# === è¡¨æ ¼ç»„ä»¶ (ä¿æŒä¸å˜) ===
class DraggableTableWidget(QTableWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setDragEnabled(True)
        self.setAcceptDrops(True)
        self.setDragDropMode(QAbstractItemView.InternalMove)
        self.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.setSelectionMode(QAbstractItemView.ExtendedSelection)
        self.setDropIndicatorShown(True)

    def dropEvent(self, event):
        try:
            if event.source() != self: super().dropEvent(event); return
            s_row, t_idx = self.currentRow(), self.indexAt(event.pos())
            t_row = t_idx.row() if t_idx.row() != -1 else self.rowCount() - 1
            if s_row == t_row: return
            row_items = [self.takeItem(s_row, c) for c in range(self.columnCount())]
            self.removeRow(s_row)
            if s_row < t_row: t_row -= 1
            self.insertRow(t_row)
            for c, item in enumerate(row_items): self.setItem(target_row, c, item)
            self.selectRow(target_row)
            new_ids = []
            for r in range(self.rowCount()):
                if self.item(r, 0): self.item(r, 0).setText(str(r + 1))
                if self.item(r, 9): new_ids.append(int(self.item(r, 9).text()))
            mw = self.window()
            if hasattr(mw, 'update_db_order'): mw.update_db_order(new_ids)
            if hasattr(mw, 'load_data'): mw.load_data(select_id=new_ids[t_row] if t_row < len(new_ids) else None)
            event.accept()
        except Exception as e: log.critical(f"DropEvent å´©æºƒ: {e}", exc_info=True)

# === å†å²ç›¸å…³ (ä¿æŒä¸å˜) ===
class HistoryChip(QWidget):
    clicked = pyqtSignal(str); deleted = pyqtSignal(str)
    def __init__(self, text, parent=None):
        super().__init__(parent); self.text = text; self.setFixedHeight(32)
        layout = QHBoxLayout(self); layout.setContentsMargins(8, 0, 4, 0); layout.setSpacing(4)
        b_c = QPushButton(f"ğŸ•’ {text}"); b_c.setCursor(Qt.PointingHandCursor); b_c.setStyleSheet("QPushButton { background: transparent; border: none; color: #cdd6f4; text-align: left; font-size: 13px; } QPushButton:hover { color: #89b4fa; }"); b_c.clicked.connect(lambda: self.clicked.emit(self.text)); layout.addWidget(b_c, 1)
        b_d = QPushButton("Ã—"); b_d.setCursor(Qt.PointingHandCursor); b_d.setFixedSize(20, 20); b_d.setStyleSheet("QPushButton { background: transparent; border: none; color: #6c7086; font-weight: bold; font-size: 14px; border-radius: 10px; } QPushButton:hover { background-color: #f38ba8; color: #1e1e2e; }"); b_d.clicked.connect(lambda: self.deleted.emit(self.text)); layout.addWidget(b_d)
        self.setObjectName("HistoryChip"); self.setStyleSheet("#HistoryChip { background-color: transparent; border-bottom: 1px solid #313244; } #HistoryChip:hover { background-color: #313244; }")
    def mousePressEvent(self, e): 
        if self.childAt(e.pos()) != self.children()[2]: self.clicked.emit(self.text)
        super().mousePressEvent(e)

class HistoryPopupWidget(QWidget):
    itemSelected = pyqtSignal(str)
    def __init__(self, parent=None):
        super().__init__(parent); self.setWindowFlags(Qt.Popup | Qt.FramelessWindowHint); self.setAttribute(Qt.WA_TranslucentBackground)
        self.main_layout = QVBoxLayout(self); self.main_layout.setContentsMargins(0, 0, 0, 0)
        self.scroll = QScrollArea(); self.scroll.setWidgetResizable(True); self.scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff); self.scroll.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)
        self.scroll.setStyleSheet("QScrollArea { border: 1px solid #45475a; border-radius: 6px; background-color: #181825; } QWidget#ScrollContents { background-color: #181825; } QScrollBar:vertical { background: #11111b; width: 6px; } QScrollBar::handle:vertical { background: #45475a; border-radius: 3px; }")
        self.content_widget = QWidget(); self.content_widget.setObjectName("ScrollContents"); self.v_layout = QVBoxLayout(self.content_widget); self.v_layout.setContentsMargins(2, 2, 2, 2); self.v_layout.setSpacing(0); self.scroll.setWidget(self.content_widget); self.main_layout.addWidget(self.scroll)
        self.history_data = []; self.settings = None
    def load_history(self, h, s): self.history_data = h; self.settings = s; self.refresh_ui()
    def refresh_ui(self):
        while self.v_layout.count(): item = self.v_layout.takeAt(0); item.widget().deleteLater() if item.widget() else None
        if not self.history_data: 
            lbl = QLabel("æš‚æ— æœç´¢è®°å½•"); lbl.setStyleSheet("color: #6c7086; font-style: italic; padding: 10px;"); lbl.setAlignment(Qt.AlignCenter); self.v_layout.addWidget(lbl); self.setFixedSize(260, 50); return
        for t in self.history_data: c = HistoryChip(t); c.clicked.connect(self.on_clk); c.deleted.connect(self.on_del); self.v_layout.addWidget(c)
        self.v_layout.addStretch(); h = len(self.history_data) * 32 + 10; self.setFixedSize(260, min(h, 350))
    def on_clk(self, t): self.itemSelected.emit(t); self.hide()
    def on_del(self, t): 
        if t in self.history_data: self.history_data.remove(t); self.settings.setValue("items", self.history_data); self.refresh_ui()

class HistoryLineEdit(QLineEdit):
    def __init__(self, parent=None):
        super().__init__(parent); self.popup = HistoryPopupWidget(self); self.popup.itemSelected.connect(self.sel_hist)
        self.settings = QSettings("ClipboardApp", "SearchHistory"); self.history = self.settings.value("items", [])
        if not isinstance(self.history, list): self.history = []
        self.returnPressed.connect(self.save_hist); self.installEventFilter(self)
    def save_hist(self):
        t = self.text().strip(); 
        if not t: return
        if t in self.history: self.history.remove(t)
        self.history.insert(0, t); self.history = self.history[:16]; self.settings.setValue("items", self.history); self.popup.hide()
    def sel_hist(self, t): self.setText(t); self.returnPressed.emit(); self.popup.hide()
    def eventFilter(self, o, e):
        if o == self:
            if e.type() == QEvent.MouseButtonPress and not self.popup.isVisible(): self.show_popup()
            elif e.type() == QEvent.FocusIn and not self.popup.isVisible(): QTimer.singleShot(100, self.show_popup)
        return super().eventFilter(o, e)
    def show_popup(self): self.popup.load_history(self.history, self.settings); p = self.mapToGlobal(self.rect().bottomLeft()); p.setY(p.y() + 5); self.popup.move(p); self.popup.show()

# === æ™®é€šç­›é€‰ Chip ===
class FilterChip(QPushButton):
    def __init__(self, text, icon_char="", color="#89b4fa", parent=None):
        super().__init__(f"{icon_char} {text}", parent)
        self.setCheckable(True); self.setCursor(Qt.PointingHandCursor); self.setFixedHeight(28)
        self.setStyleSheet(f"""
            QPushButton {{ background: transparent; border: 1px solid {color}; border-radius: 14px; color: #cdd6f4; padding: 0 12px; font-weight: bold; }}
            QPushButton:hover {{ background-color: {color}; color: #1e1e2e; }}
            QPushButton:checked {{ background-color: {color}; border: 1px solid {color}; color: #1e1e2e; }}
        """)

# === æ˜Ÿçº§ç­›é€‰ Chip ===
class StarFilterChip(QPushButton):
    filterChanged = pyqtSignal(list)
    def __init__(self, parent=None):
        super().__init__("â­ æ˜Ÿçº§", parent); self.setCursor(Qt.PointingHandCursor); self.setFixedHeight(28); self.selected_levels = set()
        self.base_style = """ QPushButton { background: transparent; border: 1px solid #f9e2af; border-radius: 14px; color: #cdd6f4; padding: 0 12px; font-weight: bold; } QPushButton:hover { background-color: #f9e2af; color: #1e1e2e; } """
        self.active_style = """ QPushButton { background-color: #f9e2af; border: 1px solid #f9e2af; border-radius: 14px; color: #1e1e2e; padding: 0 12px; font-weight: bold; } """
        self.setStyleSheet(self.base_style); self.menu = QMenu(self); self.menu.setStyleSheet("QMenu { background: #1e1e2e; border: 1px solid #45475a; } QMenu::item { color: #cdd6f4; } QMenu::item:selected { background: #313244; }")
        self.actions = {}
        for i in range(1, 6): a = QAction(f"{'â˜…'*i} ({i}æ˜Ÿ)", self); a.setCheckable(True); a.setData(i); a.triggered.connect(self.on_act); self.menu.addAction(a); self.actions[i] = a
        self.clicked.connect(self.show_menu)
    def show_menu(self): p = self.mapToGlobal(self.rect().bottomLeft()); p.setY(p.y() + 2); self.menu.exec_(p)
    def on_act(self):
        self.selected_levels = {i for i, a in self.actions.items() if a.isChecked()}
        if self.selected_levels: self.setStyleSheet(self.active_style); s = sorted(list(self.selected_levels)); self.setText(f"â­ {','.join(map(str, s))}")
        else: self.setStyleSheet(self.base_style); self.setText("â­ æ˜Ÿçº§")
        self.filterChanged.emit(list(self.selected_levels))
    def reset(self): [a.setChecked(False) for a in self.actions.values()]; self.selected_levels.clear(); self.setStyleSheet(self.base_style); self.setText("â­ æ˜Ÿçº§"); self.filterChanged.emit([])

# === ğŸŒŸ æ ¸å¿ƒæ–°å¢ï¼šæ—¥æœŸç­›é€‰ Chip (ä¸‹æ‹‰èœå•) ===
class DateFilterChip(QPushButton):
    filterChanged = pyqtSignal(tuple) # (start_date, end_date)

    def __init__(self, name, icon, color, parent=None):
        super().__init__(f"{icon} {name}", parent)
        self.default_text = f"{icon} {name}"
        self.base_color = color
        self.setCursor(Qt.PointingHandCursor)
        self.setFixedHeight(28)
        self.current_range = None # (start, end)
        
        self.base_style = f"""
            QPushButton {{ background: transparent; border: 1px solid {color}; border-radius: 14px; color: #cdd6f4; padding: 0 12px; font-weight: bold; }}
            QPushButton:hover {{ background-color: {color}; color: #1e1e2e; }}
        """
        self.active_style = f"""
            QPushButton {{ background-color: {color}; border: 1px solid {color}; border-radius: 14px; color: #1e1e2e; padding: 0 12px; font-weight: bold; }}
        """
        self.setStyleSheet(self.base_style)
        
        # èœå•
        self.menu = QMenu(self)
        self.menu.setStyleSheet(f"""
            QMenu {{ background-color: #1e1e2e; border: 1px solid {color}; padding: 5px; }}
            QMenu::item {{ padding: 6px 20px; color: #cdd6f4; }}
            QMenu::item:selected {{ background-color: #313244; color: {color}; }}
        """)
        
        # é€‰é¡¹
        self.options = [
            ("ä»Šæ—¥", 0), ("å‘¨å†…", 7), ("ä¸¤å‘¨", 14), ("æœ¬æœˆ", 30), ("ä¸Šæœˆ", -1), ("è‡ªå®šä¹‰...", -99)
        ]
        
        for text, val in self.options:
            action = QAction(text, self)
            action.setData(val)
            action.triggered.connect(lambda _, v=val, t=text: self.set_range(v, t))
            self.menu.addAction(action)
            
        self.clicked.connect(self.show_menu)

    def show_menu(self):
        pos = self.mapToGlobal(self.rect().bottomLeft())
        pos.setY(pos.y() + 2)
        self.menu.exec_(pos)

    def set_range(self, val, text):
        now = datetime.now()
        start_date = None
        end_date = now.date() # é»˜è®¤ç»“æŸæ˜¯ä»Šå¤©
        
        if val == -99: # è‡ªå®šä¹‰
            self.open_custom_dialog()
            return
        elif val == 0: # ä»Šæ—¥
            start_date = now.date()
        elif val == -1: # ä¸Šæœˆ
            # è®¡ç®—ä¸Šä¸ªæœˆç¬¬ä¸€å¤©å’Œæœ€åä¸€å¤©
            first_day_this_month = now.replace(day=1)
            last_day_prev_month = first_day_this_month - timedelta(days=1)
            start_date = last_day_prev_month.replace(day=1).date()
            end_date = last_day_prev_month.date()
        elif val == 30: # æœ¬æœˆ
            start_date = now.replace(day=1).date()
        else: # å‘¨å†… / ä¸¤å‘¨å†…
            start_date = (now - timedelta(days=val)).date()
            
        self.current_range = (start_date, end_date)
        self.setText(f"{text}")
        self.setStyleSheet(self.active_style)
        self.filterChanged.emit(self.current_range)

    def open_custom_dialog(self):
        dlg = MiniDateRangeDialog(self)
        if dlg.exec_():
            self.current_range = dlg.get_range()
            self.setText(f"è‡ªå®šä¹‰")
            self.setStyleSheet(self.active_style)
            self.filterChanged.emit(self.current_range)

    def reset(self):
        self.current_range = None
        self.setText(self.default_text)
        self.setStyleSheet(self.base_style)
        self.filterChanged.emit((None, None))

# === è¿·ä½ æ—¥æœŸé€‰æ‹©å¼¹çª— (é…åˆè‡ªå®šä¹‰ä½¿ç”¨) ===
class MiniDateRangeDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("é€‰æ‹©æ—¥æœŸèŒƒå›´")
        self.setWindowFlags(Qt.Popup) # æ— è¾¹æ¡†å¼¹çª—
        self.setStyleSheet("QDialog { background: #181825; border: 1px solid #45475a; } QLabel { color: #cdd6f4; }")
        
        layout = QVBoxLayout(self)
        
        h = QHBoxLayout()
        self.d1 = QDateEdit(QDate.currentDate().addDays(-7)); self.d1.setCalendarPopup(True)
        self.d2 = QDateEdit(QDate.currentDate()); self.d2.setCalendarPopup(True)
        h.addWidget(QLabel("ä»")); h.addWidget(self.d1); h.addWidget(QLabel("åˆ°")); h.addWidget(self.d2)
        layout.addLayout(h)
        
        btn = QPushButton("ç¡®å®š")
        btn.setStyleSheet("background: #89b4fa; color: #1e1e2e; border-radius: 4px; padding: 4px;")
        btn.clicked.connect(self.accept)
        layout.addWidget(btn)

    def get_range(self):
        return (self.d1.date().toPyDate(), self.d2.date().toPyDate())

# === ç°ä»£åŒ–ç­›é€‰æ  ===
class ModernFilterBar(QWidget):
    filterChanged = pyqtSignal()

    def __init__(self, parent=None):
        super().__init__(parent)
        layout = QHBoxLayout(self); layout.setContentsMargins(0, 0, 0, 0); layout.setSpacing(8)

        self.search_input = HistoryLineEdit()
        self.search_input.setPlaceholderText("ğŸ” æœç´¢å†…å®¹æˆ–å¤‡æ³¨...")
        self.search_input.setFixedHeight(30); self.search_input.setFixedWidth(260)
        self.search_input.setStyleSheet("QLineEdit { background: #11111b; border: 1px solid #89b4fa; border-radius: 15px; padding: 0 12px; color: #cdd6f4; } QLineEdit:focus { border: 2px solid #89b4fa; }")
        self.search_input.returnPressed.connect(self.filterChanged.emit)
        layout.addWidget(self.search_input)

        line = QFrame(); line.setFrameShape(QFrame.VLine); line.setFrameShadow(QFrame.Sunken); line.setFixedHeight(20); line.setStyleSheet("color: #45475a;")
        layout.addWidget(line)

        self.btn_reset = QPushButton("â†º é‡ç½®")
        self.btn_reset.setCursor(Qt.PointingHandCursor); self.btn_reset.setToolTip("æ¸…é™¤æ‰€æœ‰ç­›é€‰æ¡ä»¶"); self.btn_reset.setFixedHeight(28)
        self.btn_reset.setStyleSheet("QPushButton { background: transparent; border: 1px solid #cba6f7; border-radius: 14px; color: #cdd6f4; font-weight: bold; padding: 0 12px; } QPushButton:hover { background-color: #cba6f7; color: #1e1e2e; }")
        self.btn_reset.clicked.connect(self.reset_filters)
        layout.addWidget(self.btn_reset)

        self.chip_fav = FilterChip("æ”¶è—", "â¤ï¸", "#f38ba8")
        self.chip_lock = FilterChip("é”å®š", "ğŸ”’", "#fab387")
        self.chip_file = FilterChip("æ–‡ä»¶", "ğŸ“„", "#a6e3a1")
        self.chip_star = StarFilterChip()
        self.chip_star.filterChanged.connect(lambda: self.filterChanged.emit())
        
        # === æ–°å¢: æ—¥æœŸç­›é€‰ Chips ===
        self.chip_date_created = DateFilterChip("åˆ›å»ºæ—¥æœŸ", "ğŸ“…", "#89dceb")
        self.chip_date_created.filterChanged.connect(lambda: self.filterChanged.emit())
        
        self.chip_date_modified = DateFilterChip("ä¿®æ”¹æ—¶é—´", "ğŸ“", "#f5e0dc")
        self.chip_date_modified.filterChanged.connect(lambda: self.filterChanged.emit())

        # æ·»åŠ æ‰€æœ‰ç»„ä»¶
        for chip in [self.chip_fav, self.chip_lock, self.chip_file]:
            chip.clicked.connect(self.filterChanged.emit) 
            layout.addWidget(chip)
        
        layout.addWidget(self.chip_star) 
        layout.addWidget(self.chip_date_created) # æ–°å¢
        layout.addWidget(self.chip_date_modified) # æ–°å¢
        layout.addStretch()

    def get_filters(self):
        return {
            "search": self.search_input.text().strip(),
            "is_favorite": self.chip_fav.isChecked(),
            "is_locked": self.chip_lock.isChecked(),
            "is_file": self.chip_file.isChecked(),
            "star_levels": list(self.chip_star.selected_levels),
            "date_created": self.chip_date_created.current_range, # (start, end) or None
            "date_modified": self.chip_date_modified.current_range # (start, end) or None
        }

    def reset_filters(self):
        self.search_input.clear()
        for chip in [self.chip_fav, self.chip_lock, self.chip_file]: chip.setChecked(False)
        self.chip_star.reset()
        self.chip_date_created.reset()
        self.chip_date_modified.reset()
        self.filterChanged.emit()

